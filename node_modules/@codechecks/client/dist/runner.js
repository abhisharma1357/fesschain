#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("./utils/hijackModuleLoading");
const util_1 = require("util");
const program = require("commander");
const ms = require("ms");
const ci_providers_1 = require("./ci-providers");
const getExecutionContext_1 = require("./getExecutionContext");
const api_1 = require("./api");
const client_1 = require("./client");
const utils_1 = require("./utils");
const execution_1 = require("./file-executors/execution");
const _1 = require(".");
const Local_1 = require("./ci-providers/Local");
const logger_1 = require("./logger");
const settings_1 = require("./file-handling/settings");
const git_1 = require("./utils/git");
async function main(project, codecheckFiles = execution_1.findCodechecksFiles(process.cwd())) {
    logger_1.printLogo();
    logger_1.logger.log(`Executing ${logger_1.bold(codecheckFiles.length)} codechecks files`);
    const startTime = new Date().getTime();
    const provider = ci_providers_1.findProvider(process.env, project);
    const requiresSecret = Local_1.checkIfIsLocalMode(provider) || (await provider.isFork());
    const api = new api_1.Api(api_1.getApiOptions(requiresSecret));
    if (provider.setApi) {
        provider.setApi(api);
    }
    const gitRoot = git_1.findRootGitRepository(process.cwd());
    if (!gitRoot) {
        throw new Error("Couldn't find project root!");
    }
    const settings = await settings_1.loadCodechecksSettings(gitRoot);
    const sharedExecutionCtx = await getExecutionContext_1.getConstExecutionContext(api, provider, settings, gitRoot);
    logger_1.logger.debug({ sharedExecutionCtx });
    api.sharedCtx = sharedExecutionCtx;
    if (sharedExecutionCtx.isFork) {
        logger_1.logger.log("Running for fork!");
    }
    if (sharedExecutionCtx.isLocalMode) {
        logger_1.logger.log("Running in local mode!");
    }
    if (sharedExecutionCtx.isPr) {
        logger_1.logger.log(`Base branch: ${logger_1.bold(logger_1.formatSHA(sharedExecutionCtx.pr.base.sha))}`);
    }
    console.log();
    for (const codecheckFile of codecheckFiles) {
        logger_1.logger.log(`Executing ${logger_1.bold(logger_1.formatPath(codecheckFile, gitRoot))}...`);
        logger_1.logger.log();
        // do not use this instance after clone
        const fileExecutionCtx = getExecutionContext_1.getExecutionContext(sharedExecutionCtx, codecheckFile);
        logger_1.logger.debug({ fileExecutionCtx });
        const _client = new client_1.CodechecksClient(api, fileExecutionCtx);
        replaceObject(_1.codechecks, _client);
        global.__codechecks_client = _client;
        await execution_1.executeCodechecksFile(codecheckFile);
    }
    const finishTime = new Date().getTime();
    const deltaTime = finishTime - startTime;
    logger_1.logger.log(`All done in ${logger_1.bold(ms(deltaTime))}!`);
}
const command = program
    .version(require("../package.json").version)
    .option("-p, --project [projectSlug]", "Project slug, useful only in local mode, otherwise ignored")
    .usage("codechecks [codechecks.yml|json|ts|js]")
    .parse(process.argv);
main(command.project, command.args.length > 0 ? command.args.map(a => utils_1.normalizePath(a)) : undefined).catch(e => {
    // we want informative output but we don't want leaking secrets into any logs
    logger_1.logger.error(utils_1.maskSecrets(e.message, process.env));
    logger_1.logger.debug(utils_1.maskSecrets(util_1.inspect(e), process.env));
    process.exit(1);
});
// @todo is there a way to avoid doing prototype shenanigans also without polluting index.js by introducing something like __setClient?
function replaceObject(old, newObject) {
    Object.assign(old, newObject);
    old.__proto__ = newObject.__proto__;
}
//# sourceMappingURL=runner.js.map