"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const execution_1 = require("../file-executors/execution");
const path_1 = require("path");
const executeJson_1 = require("../file-executors/executeJson");
describe("executeCodechecksFiles", () => {
    // NOTE: these tests do not make awful lot of sense since everything is ran with ts-node anyway
    it("should work with typescript", async () => {
        const filenames = [
            path_1.join(__dirname, "./modules/export-default.ts"),
            path_1.join(__dirname, "./modules/export-named.ts"),
            path_1.join(__dirname, "./modules/export-commonjs.ts"),
        ];
        for (const filename of filenames) {
            await execution_1.executeCodechecksFile(filename);
            // any better idea to communicate between modules?
            expect(global[filename]).toBe(true);
        }
    });
    it("should work with javascript", async () => {
        const filenames = [path_1.join(__dirname, "./modules/export-commonjs.js")];
        for (const filename of filenames) {
            await execution_1.executeCodechecksFile(filename);
            expect(global[filename]).toBe(true);
        }
    });
    it("should work with json", async () => {
        const dummyJsonConfig = {
            checks: [{ name: "build-size-watcher", options: { paths: [{ path: "build/**/*.js" }] } }],
        };
        const moduleFullPath = path_1.join(__dirname, "./modules/loaded-by-json.ts");
        const dummyNameResolver = (checkName) => {
            expect(checkName).toBe("build-size-watcher");
            return moduleFullPath;
        };
        await executeJson_1.executeCodechecksJsonString(dummyJsonConfig, dummyNameResolver);
        expect(global[moduleFullPath]).toBe(true);
    });
});
//# sourceMappingURL=executeCodechecksFile.test.js.map